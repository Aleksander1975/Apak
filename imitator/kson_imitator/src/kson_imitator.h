#ifndef KSON_IMITATOR_H
#define KSON_IMITATOR_H

#include <QMutex>
#include <QMutexLocker>

#include "kson_imitator_global.h"

#include "../../../../Modus/global/device/protocol/sv_abstract_protocol.h"
#include "../../../../Modus/global/signal/sv_signal.h"

#include "protocol_params.h"
#include "signal_params.h"

#include "../../../../svlib/SvAbstractLogger/1.2/sv_abstract_logger.h"
#include "../../../../svlib/SvException/1.1/sv_exception.h"
#include "../../../../svlib/SvCRC/1.1/sv_crc.h"

extern "C" {

    KSON_IMITATOR_EXPORT modus::SvAbstractProtocol* create();

}

namespace apak {

  class SvKsonImitator: public modus::SvAbstractProtocol
  // Класс, реализующий программный имитатор сети КСОН.
  {
    Q_OBJECT

  public:
    // Инициализация структур данных, необходимых для формирования информационного кадра
    // от имитатора КСОН к АПАК, и структур данных, необходимых для разбора информационного
    // кадра от АПАК к иминатору КСОН:
    SvKsonImitator();
    ~SvKsonImitator();

    // Эта функция вызывается серевером "mdserver" для всех имитаторов устройств.
    // Её цель - инициализировать все структуры, необходимые нам для конкретного
    // имитатора (в данном случае, имитатора сети КСОН).
    bool configure(modus::DeviceConfig* config, modus::IOBuffer *iobuffer) override;

    // Эта функция вызывается сервером "mdserver" для всех сигналов имитатора, связанных с сетью КСОН. Эти
    // сигналы описываются в файле "kson.json".
    // Перечислим эти сигналы:
    // 1. Сигналы параметрической информации, отправляемые в информационном кадре от имитатора КСОН к АПАК.
    //    Эти сигналы имеют привязку "binding".
    // 2. Сигналы от системы АПАК к сети КСОН. Это сигналы о состоянии ПУ1 и ПУ2 системы АПАК и о состоянии
    //    сопряжения АПАК с другими устройствами (СКМ, ИВ-1, КРАБ...)
    //    Эти сигналы имеют привязку "master".
    //    Эти сигналы нужны нам для возможности разбора значений этих сигналов с целью дальнейшего отображения
    //     их значений на консоль и в утилите "logview".

    // Цель этой функции состоит в получении всех параметров для каждого сигнала и заполнении в соответствии
    // с ними структур данных (перечисленных в файле "kson_imitator.h"), необходимых для формирования информационного кадра от
    // имитатора сети КСОН в систему АПАК и отображения на консоли и в утилите "logview" значений сигналов
    // информационного кадра от системы АПАК к сети КСОН.
    bool bindSignal(modus::SvSignal* signal, modus::SignalBinding binding) override;

  private:

    // Cодержит параметры протокола обмена сети КСОН с системой АПАК
    // (эти параметры описаны в файле "protokol_param.h").
    apak::ProtocolParams  m_params;

    // "Таймер посылки" - таймер, отсчитывающий период посылки информационных
    // кадров от сети КСОН к системе АПАК:
    QTimer* m_sendTimer;

    // "Таймер приёма" - таймер, отсчитывающий предельно допустимое время между информационными
    // кадрами от системы АПАК к сети КСОН:
    QTimer* m_receiveTimer;

    // "Таймер подтверждения" - таймер, отсчитывающий предельно допустимое время от
    // посылки нами информационного кадра к системе АПАК, до получения нами
    // пакета подтверждения от системы АПАК.
    QTimer* m_conformTimer;

    // Время посылки информационного кадра от имитатора КСОН к АПАК. Оно необходимо нам, чтобы проверить,
    // что в пакете подтверждения от АПАК указано то же самое время.
    quint64 m_packetTimeTo_APAK;

    // Время из информационного кадра от APAK. Оно необходимо нам, чтобы использовать его
    // в пакете подтверждения на этот информационный кадр:
    quint64 m_packetTimeFrom_APAK;

    // Счётчик подряд идущих ошибок взаимодействия АПАК с КСОН:
    uint m_interactionErrorCounter;

    // В этой переменной, при разборе информационного кадра от КСОН,
    // формируем поле статуса пакета подтверждения:
    uint8_t m_status;


    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ ФОРМИРОВАНИЯ ИНФОРМАЦИОННОГО КАДРА ОТ имитатора КСОН к АПАК ====:
    // 1И. Словарь, который каждому смещению (в байтах) значения сигнала относительно начала информационного
    // блока, передаваемого из КСОН в АПАК, ставит в соответствие указатель на этот сигнал.
    QMap<uint8_t, modus::SvSignal*> m_signals_by_byte_to_APAK;

    // 2И. Список указателей на сигналы, отсортированный по возрастанию смещений
    // значений сигналов (в байтах) относительно начала информационного блока,
    // передаваемого из КСОН в АПАК.
    QList <modus::SvSignal*> m_signals_to_APAK;

    // 3И. Словарь, который каждому сигналу ставит в соответствие структуру SignalParams,
    // хранящую параметры для этого сигнала:
    QMap<modus::SvSignal*, apak::SignalParams> m_params_by_signal_to_APAK;

    // 4И. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    // определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    // В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из наличия сигналов с
    // параметром, указывающим на принадлежность к данной группе, в файле сигналов устройства КСОН.
    QBitArray m_relevance_by_group_to_APAK;

    // 5И. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    // определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    // В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из актуальности и соответствия
    // указанному в сигнале типу содержимого переменной "m_value" типа QVariant в классе сигнала.
    QBitArray m_relevanceConcrete_by_group_to_APAK;

    // 6И. Массив данных для передачи от КСОН в систему АПАК в соответствии с протоколом обмена.
    QByteArray m_send_data;

    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ РАЗБОРА ИНФОРМАЦИОННОГО КАДРА ОТ АПАК К имитатору КСОН====:
    // 1В. Битовый массив размером m_params.data_len*8 битов, в котором информационный "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к имитатору КСОН:
    QBitArray m_bitsInformBlock_from_APAK;

    // 2В. Байтовый массив размером m_params.data_len байтов, в котором находится "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к имитатору КСОН:
    QByteArray m_byteInformBlock_from_APAK;

    // 3В. Битовый массив, который для каждого номера группы сигналов от АПАК к имитатору КСОН
    //    (номер - это индекс в этом массиве),
    //    устанавливает актуальны ли её сигналы (false - не актуальны, true - актуальны).
    QBitArray m_relevance_by_group_from_APAK;

    // 4В. Байтовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это номер бита в этом массиве),
    //    устанавливает актуальны ли её сигналы: значение бита 0 - не актуальны, 1 - актуальны).
    QByteArray m_relevanceGroup_Byte_from_APAK;

    // 5В. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock_from_APAK" ставит в соответствие сигнал, бит которого должен быть записан
    //    в массив "m_bitsInformBlock":
    QMap<uint16_t, modus::SvSignal*> m_signal_by_bitNumberInInformBlock_from_APAK;

    // 6В. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock_from_APAK", ставит в соответствие номер бита сигнала, который
    //    должен быть записан в массив "m_bitsInformBlock_from_APAK":
    QMap<uint16_t, uint8_t> m_bitNumberInSignal_by_bitNumberInInformBlock_from_APAK;

  public slots:
    void signalUpdated(modus::SvSignal* signal) override;
    void signalChanged(modus::SvSignal* signal) override;

    // В этой функции мы осуществляем:
    // 1. Cформируем список "m_signals_to_APAK", хранящий указатели на сигналы исходящие от КСОН.
    //    Этот список отсортирован по возрастанию смещений значений сигналов (в байтах) относительно
    //    начала информационного блока, передаваемого из КСОН в АПАК.
    // 2. Привязываем вызов функции "noReceivePackage" к наступлению таймаута
    //    таймера приёма "m_receiveTimer". В этой функции мы будем фиксировать отсутствие
    //    информационного кадра от АПАК.
    // 3. Запускаем таймер приёма "m_receiveTimer" с периодом, равным предельно допустимому времени
    //    между получением информационных кадров от АПАК, заданному  в конфигурационном файле
    //   "config_apak_imitator.json", как параметр протокола устройства КСОН
    // 4. Привязываем вызов функции "noConfirmationPackage" к наступлению таймаута
    //    таймера подтверждения "m_conformTimer". В этой функции мы будем фиксировать
     //   ошибку взаимодействия КСОН и АПАК.
    // 5. Привязку вызова функции "sendInformFrame" , в которой мы
    //    формируем информационный кадр от имитатора сети КСОН к системе АПАК, к наступлению таймаута
    //    таймера посылки "m_sendTimer".
    // 6. Запускаем на единственное срабатывание таймер посылки "m_sendTimer" с периодом,
    //    равным интервалу посылки информационных кадров,
    //    от КСОН к АПАК, заданному  в конфигурационном файле "config_apak_imitator.json", как параметр
    //    протокола устройства КСОН. Далее будем запускать
    //    этот таймер каждый раз после получения пакета подтверждения от системы АПАК.
    // 7. Привязку вызова функции "messageFrom_APAK", к сигналу "modus::IOBuffer::dataReaded". Этот сигнал
    //    испускается интерфейсной частью по приходу данных от интерефейса (в нашем случае - от системы АПАК).
    //    В этой функции мы обрабатываем принятый от системы АПАК информационный кадр или пакет подтверждения.
    // 8. Сброс счётчика идущих подряд ошибок взаимодействия КСОН и АПАК
    void start() override;

  private slots:

    // В этой функции мы:
    // 1. Формируем и помещаем в массив байт "m_send_data" информационный кадр для передачи от имитатора
    // сети КСОН в систему АПАК (в соответствии с протоколом обмена)
    // 2. Инициируем передачу этого кадра от протокольной к интерфейcной части имитатора (для передачи по линии связи).
    // 3. Запускаем таймер подтверждения "m_conformTimer", который отсчитывает
    // предельно допустимое время от посылки нами информационного кадра в систему АПАК,
    // до получения нами пакета подтверждения от системы АПАК.
    void sendInformFrame();

    // В этой функции мы обрабатываем принятое от системы АПАК сообщение.
    // Это сообщение, может состоять:
    // - из информационного кадра
    // - из пакета подтверждения
    // - из информационного кадра и пакета подтверждения в любом порядке.

    // Мы последовательно обрабатываем пакеты, из которых состоит принятое сообщение.
    // Тип пакета (информационный кадр или пакет подтверждения) мы определем по полю
    // размера данных.
    void messageFrom_APAK(modus::BUFF* buffer);

    // Функция осуществляет выделение из принятого от АПАК сообщения одного пакета и,
    // в зависимости от вида пакета (информационный кадр или пакет подтверждения), вызов для
    // его разбора сооответствующей функции:
    void analysisMessageFrom_APAK(QByteArray& messageFrom_APAK);

    // Функция обработки пришедшего от АПАК информационного кадра:
    // Аргумент функции: "packageFrom_APAK" - содержит информационный кадр от АПАК.
    void informFrameFrom_APAK (QByteArray packageFrom_APAK);

     // Функция обработки пришедшего от АПАК пакета подтверждения:
     // Аргумент функции: "packageFrom_APAK" - содержит пакет подтверждения от АПАК.
    void  confirmationPackageFrom_APAK (QByteArray packageFrom_APAK);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // посылки нами информационного кадра к АПАК, до получения нами пакета подтверждения от АПАК
    // пакет подтверждения так и не пришёл.
    void noConfirmationPackage(void);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // АПАК не пришёл инфомационный кадр.
    void noReceivePackage (void);

    // Формирование и посылка пакета подтверждения.
    void sendConfirmationPackage (void);

    // Обработка ошибки протокола.
    void protocolErrorHandling (QString str);

  };
}


#endif // KSON_IMITATOR_H
