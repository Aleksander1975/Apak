#ifndef KSON_IMITATOR_H
#define KSON_IMITATOR_H

#include <QMutex>
#include <QMutexLocker>

#include "kson_imitator_global.h"

#include "../../../../Modus/global/device/protocol/sv_abstract_protocol.h"
#include "../../../../Modus/global/signal/sv_signal.h"

#include "protocol_params.h"
#include "signal_params.h"

#include "../../../../svlib/SvAbstractLogger/1.2/sv_abstract_logger.h"
#include "../../../../svlib/SvException/1.1/sv_exception.h"
#include "../../../../svlib/SvCRC/1.1/sv_crc.h"

extern "C" {

    KSON_IMITATOR_EXPORT modus::SvAbstractProtocol* create();

}

namespace apak {

  class SvKsonImitator: public modus::SvAbstractProtocol
  // Класс, реализующий программный имитатор сети КСОН.
  {
    Q_OBJECT

  public:
    SvKsonImitator();
    ~SvKsonImitator();

    // Эта функция вызывается серевером "mdserver" для всех имитаторов устройств.
    // Её цель - инициализировать все структуры, необходимые нам для конкретного
    // имитатора (в данном случае, имитатора сети КСОН).
    bool configure(modus::DeviceConfig* config, modus::IOBuffer *iobuffer) override;

    // Эта функция вызывается сервером "mdserver" для всех сигналов имитатора КСОН.
    // Её цель состоит в получении всех параметров для каждого сигнала и заполнинии в соответствии
    // с ними структур данных (словари "m_signal_by_byte_to_APAK", "m_params_by_signal_to_APAK",
    // "m_relevance_by_group_to_APAK"), необходимых для формирования кадра от сети КСОН к системе АПАК.
    bool bindSignal(modus::SvSignal* signal, modus::SignalBinding binding) override;

  private:

    // Cодержит параметр протокола обмена сети КСОН с системой АПАК
    // (период поступления данных в мс от КСОН в систему АПАК).
    apak::ProtocolParams  m_params;

    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ ФОРМИРОВАНИЯ ИНФОРМАЦИОННОГО КАДРА ОТ имитатора КСОН к АПАК ====:
    // 1И. Словарь, который каждому смещению (в байтах) значения сигнала относительно начала информационного
    // блока, передаваемого из КСОН в АПАК, ставит в соответствие указатель на этот сигнал.
    QMap<uint8_t, modus::SvSignal*> m_signals_by_byte_to_APAK;

    // 2И. Список указателей на сигналы, отсортированный по возрастанию смещений
    // значений сигналов (в байтах) относительно начала информационного блока,
    // передаваемого из КСОН в АПАК.
    QList <modus::SvSignal*> m_signals_to_APAK;

    // 3И. Словарь, который каждому сигналу ставит в соответствие структуру SignalParams,
    // хранящую параметры для этого сигнала:
    QMap<modus::SvSignal*, apak::SignalParams> m_params_by_signal_to_APAK;

    // 4И. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    // определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    // В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из наличия сигналов с
    // параметром, указывающим на принадлежность к данной группе, в файле сигналов устройства КСОН.
    QBitArray m_relevance_by_group_to_APAK;

    // 5И. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    // определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    // В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из актуальности и соответствия
    // указанному в сигнале типу содержимого переменной "m_value" типа QVariant в классе сигнала.
    QBitArray m_relevanceConcrete_by_group_to_APAK;

    // 6И. Массив данных для передачи от КСОН в систему АПАК в соответствии с протоколом обмена.
    QByteArray m_send_data;

    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ РАЗБОРА ИНФОРМАЦИОННОГО КАДРА ОТ АПАК К имитатору КСОН====:
    // 1В. Битовый массив размером m_params.data_len*8 битов, в котором информационный "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к имитатору КСОН:
    QBitArray m_bitsInformBlock_from_APAK;

    // 2В. Байтовый массив размером m_params.data_len байтов, в котором находится "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к имитатору КСОН:
    QByteArray m_byteInformBlock_from_APAK;

    // 3В. Битовый массив, который для каждого номера группы сигналов от АПАК к имитатору КСОН
    //    (номер - это индекс в этом массиве),
    //    устанавливает актуальны ли её сигналы (false - не актуальны, true - актуальны).
    QBitArray m_relevance_by_group_from_APAK;

    // 4В. Байтовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это номер бита в этом массиве),
    //    устанавливает актуальны ли её сигналы: значение бита 0 - не актуальны, 1 - актуальны).
    QByteArray m_relevanceGroup_Byte_from_APAK;

    // 5В. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock_from_APAK" ставит в соответствие сигнал, бит которого должен быть записан
    //    в массив "m_bitsInformBlock":
    QMap<uint16_t, modus::SvSignal*> m_signal_by_bitNumberInInformBlock_from_APAK;

    // 6В. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock_from_APAK", ставит в соответствие номер бита сигнала, который
    //    должен быть записан в массив "m_bitsInformBlock_from_APAK":
    QMap<uint16_t, uint8_t> m_bitNumberInSignal_by_bitNumberInInformBlock_from_APAK;

    // "Таймер посылки" - таймер, отсчитывающий период посылки информационных
    // кадров от сети КСОН к системе АПАК:
    QTimer* m_sendTimer;

    // "Таймер приёма" - таймер, отсчитывающий предельно допустимое время между информационными
    // кадрами от системы АПАК к сети КСОН:
    QTimer* m_receiveTimer;

    // "Таймер подтверждения" - таймер, отсчитывающий предельно допустимое время от
    // посылки нами информационного кадра к системе АПАК, до получения нами
    // пакета подтверждения от системы АПАК.
    QTimer* m_conformTimer;

    // Время посылки информационного кадра от имитатора КСОН к АПАК. Оно необходимо нам, чтобы проверить,
    // что в пакете подтверждения от АПАК указано то же самое время.
    quint32 m_packetTimeTo_APAK;

    // Время из информационного кадра от APAK. Оно необходимо нам, чтобы использовать его
    // в пакете подтверждения на этот информационный кадр:
    quint32 m_packetTimeFrom_APAK;

    // Счётчик подряд идущих ошибок взаимодействия АПАК с КСОН:
    uint m_interactionErrorCounter;

    // В этой переменной, при разборе информационного кадра от КСОН,
    // формируем поле статуса пакета подтверждения:
    uint8_t m_status;


  public slots:
    void signalUpdated(modus::SvSignal* signal) override;
    void signalChanged(modus::SvSignal* signal) override;

    // В этой функции мы осуществляем привязку вызова функции "send" к наступлению таймаута
    // таймера "m_sendtimer", а также привязку вызова функции "answer_APAK" к сигналу
    // "modus::IOBuffer::dataReaded". Кроме того, в ней мы сформируем список "m_signals_to_APAK", хранящий
    // указатели на сигналы. Этот список отсортирован по возрастанию смещений
    // значений сигналов (в байтах) относительно начала информационного блока,
    // передаваемого из КСОН в АПАК.
    void start() override;

  private slots:

    // В этой функции мы формируем и помещаем в массив байт "m_send_data" пакет для передачи от имитатора
    // сети КСОН в систему АПАК (в соответствии с протоколом обмена) и инициируем передачу
    // этого пакета от протокольной к интерфейcной части имитатора (для передачи по линии связи).
    void sendInformFrame();

    // Эта функция вызывется по приходу пакета подтверждения от АПАК. В ней мы разбираем этот пакет
    // на отдельные поля и отображаем информацию о них в утилите "logview":
    void packageFrom_APAK(modus::BUFF* buffer);

    void noConfirmationPackage(void);
    void noReceivePackage (void);
    void sendConfirmationPackage (void);

  };
}


#endif // KSON_IMITATOR_H
