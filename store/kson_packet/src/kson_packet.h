#ifndef KSON_PACK_H
#define KSON_PACK_H


#include "kson_packet_global.h"

#include "protocol_params.h"
#include "signal_params.h"

#include "../../../global_apak_defs.h"

#include "../../../../Modus/global/device/protocol/sv_abstract_protocol.h"
#include "../../../../Modus/global/signal/sv_signal.h"
#include "../../../../svlib/SvAbstractLogger/1.2/sv_abstract_logger.h"
#include "../../../../svlib/SvException/1.1/sv_exception.h"
#include "../../../../svlib/SvCRC/1.0/sv_crc.h"


#define LIB_SHORT_INFO \
  "Библиотека АПАК для работы с КСОН. Интерфейсная библиотека Modus. Версия " LIB_VERSION ".\n"

#define LIB_DESCRIPTION \
  LIB_SHORT_INFO \
    "Библиотека АПАК для работы с КСОН реализует протокол обмена между сетью КСОН и АПАК. " \
    "\n\n1. Информационные кадры от АПАК к КСОН следуют с интервалом, заданным параметром " \
    SEND_INTERVAL ". Это реализуется с помощью \"таймера посылки m_sendTimer\". После того, как функцией " \
    "\"confirmationPackageFrom_KSON\" принят пакет подтверждения от сети КСОН, или функцией " \
    "\"noConfirmationPackage\" зафиксировано отсутствие этого пакета в течении предельно допустимого " \
    "времени, выполняется запуск \"таймера посылки m_sendTimer\" на интервал, заданный параметром " \
    SEND_INTERVAL ". По срабатыванию этого таймера вызывается функция \"sendInformFrame\", которая " \
    "формирует и посылает информационный кадр от АПАК к КСОН."\
    "\n\n2. Формируя информационный кадр от АПАК к КСОН, функция \"sendInformFrame\" использует параметр " \
    SEND_DATA_LEN ", который содержит размер информационного блока в информационном кадре от АПАК к КСОН. " \
    "\"Таймер подтверждения m_conformTimer\" позволяет контролировать своевременность получения пакета " \
    "подтверждения от сети КСОН. Для этого сразу после посылки информационного кадра функция " \
    "\"sendInformFrame\" запускает \"таймер подтверждения m_conformTimer\" с периодом, заданным параметром " \
    CONFIRM_INTERVAL ".  Срабатывание этого таймера говорит о том, что пакет подтверждения от сети КСОН " \
    "за указанное время не пришёл. В этом случае вызывается функция \"noConfirmationPackage\", которая " \
    "фиксирует факт ошибки взаимодействия (вызвав функцию \"protocolErrorHandling\") и перезапускает " \
    "\"таймер посылки\", чтобы продолжить посылать информационные кадры к сети КСОН, даже если от неё " \
    "не приходит пакетов подтверждения." \
    "\n\n3. В случае получения сообщения от сети КСОН запускается функция \"messageFrom_KSON\". " \
    "Поскольку посылка информационных кадров и получения пакетов подтверждения на них между АПАК " \
    "и сетью КСОН происходит АСИНХРОННО, то информация, полученная АПАК от сети КСОН может состоять из: " \
    "\n- одного информационного кадра," \
    "\n- одного пакета подтверждения," \
    "\n- одного информационного кадра и одного пакета подтверждения - в любом порядке.\n" \
    "Функция \"messageFrom_KSON\" разбирает принятое от сети КСОН сообщение и вызывает " \
    "для обработки информационного кадра функцию \"informFrameFrom_KSON\", а для обработки " \
    "пакета подтверждения - функцию \"confirmationPackageFrom_KSON\"." \
    "\n\n4. Функция обработки информационного кадра \"informFrameFrom_KSON\" выполняет несколько задач: " \
    "\n4.1. Разбирает содержимое кадра на отдельные поля и проверяет допустимость значений этих полей. " \
    "Для разбора кадра она использует значение параметра  " RECEIVE_DATA_LEN ", который содержит размер " \
    "информационного блока в информационном кадре от КСОН к АПАК. В случае, если значения полей кадра " \
    "допустимы, то эти значения устанавливаются в соответствующие сигналы. В противном случае - " \
    "фиксируется факт ошибки взаимодействия." \
    "\n4.2. Следит за тем, чтобы информационные кадры от сети КСОН приходили не реже, чем указано " \
    "в параметре " RECEIVE_INTERVAL ". Для этого, после приёма информацонного кадра запускается " \
    "\"таймер приёма m_receiveTimer\" на время, указанное в параметре " RECEIVE_INTERVAL ". " \
    "По приёму следующего кадра - таймер сбрасывается. Таким образом, срабатывание \"таймера приёма\" " \
    "означает, что максимальный интервал между принимаемыми кадрами - превышен. В этом случае " \
    "вызывается функция \"noReceivePackage\", которая фиксирует факт ошибки взаимодействия " \
    "(вызвав функцию \"protocolErrorHandling\") и перезапускает \"таймер приёма\", чтобы продолжать " \
    "отслеживать отсутствие информационных пакетов от сети КСОН, фиксировать в этом случае факт ошибки " \
    "взаимодействия и выдавать оператору сообщение об этом." \
    "\n4.3. Вызывает функцию \"sendConfirmationPackage\" для формирования и посылки пакета " \
    "подтверждения КСОНу." \
    "\n\n5. Функция обработки пакета подтверждения \"confirmationPackageFrom_KSON\" проверяет правильность " \
    "поступившего от КСОН пакета. В случае, если пакет нарушен или содержит в поле статуса информацию " \
    "об ошибке, производится фиксация факта ошибки взаимодействия (вызовом функции " \
    "\"protocolErrorHandling\"). После этого производится запуск \"таймера посылки m_sendTimer\" " \
    "для своевременной передачи следующего информационного кадра КСОНу." \
    "\n\n6. Фиксация факта ошибки взаимодействия производится функцией \"protocolErrorHandling\"." \
    "\nОна состоит в: " \
    "\n6.1. Выдаче оператору в утилиту \"logview\" сообщения о причине ошибки. "\
    "\n6.2. Увеличение счётчика идущих подряд ошибок взаимодействия. " \
    "\n     Примечание. Счётчик подряд идущих ошибок взаимодействия сбрасывается при:" \
    "\n                   - Приёме БЕЗ ОШИБОК информационного кадра от КСОН," \
    "\n                   - Приёме БЕЗ ОШИБОК пакета подтверждения от КСОН," \
    "\n                   - Разрыве TCP-соединения (см. пункт 6.3)." \
    "\n6.3. Разрыва TCP-соединения, в случае достижения счётчиком ошибок взаимодействия значения, "\
    "задаваемого параметром " NUMBER_OF_ERRORS "." \
    "\nАвтор: " LIB_AUTHOR


extern "C" {

     KSON_PACKET_EXPORT modus::SvAbstractProtocol* create();

     KSON_PACKET_EXPORT const char* getVersion();
     KSON_PACKET_EXPORT const char* getParams();
     KSON_PACKET_EXPORT const char* getInfo();
     KSON_PACKET_EXPORT const char* getDescription();
}

namespace apak {


  class SvKsonPacket: public modus::SvAbstractProtocol
 // Класс, реализующий библиотеку АПАК для работы с КСОН.
  {
    Q_OBJECT

  public:
    // Инициализация структур данных, необходимых для формирования информационного кадра
    // от АПАК к КСОН, и структур данных, необходимых для разбора информационного
    // кадра от КСОН:
    SvKsonPacket();
    ~SvKsonPacket();

    // Эта функция вызывается серевером "mdserver" для всех устройств.
    // Её цель - инициализировать все структуры, необходимые нам для работы
    // с конкретным устройстовм (в данном случае, с КСОН).
    bool configure(modus::DeviceConfig* config, modus::IOBuffer *iobuffer) override;

    // Эта функция вызывается сервером "mdserver" для всех сигналов, связанных с сетью КСОН.
    // Цель этой функции состоит в получении всех параметров для каждого сигнала и заполнении в соответствии
    // с ними структур данных (перечисленных в файле "kson_packet.h"), необходимых для формирования
    // информационного кадра от системы АПАК к сети КСОН и проверки допустимости значений сигналов
    // информационного кадра от сети КСОН в систему АПАК.
    bool bindSignal(modus::SvSignal* signal, modus::SignalBinding binding) override;

  private:

    // Cодержит параметры протокола обмена сети КСОН с системой АПАК
    // (эти параметры описаны в файле "protokol_param.h").
    apak::ProtocolParams  m_params;


    // "Таймер посылки" - таймер, отсчитывающий период посылки информационных
    // кадров от сисмемы АПАК к сети КСОН:
    QTimer* m_sendTimer;

    // "Таймер приёма" - таймер, отсчитывающий предельно допустимое время между информационными
    // кадрами от сети КСОН к системе АПАК:
    QTimer* m_receiveTimer;

    // "Таймер подтверждения" - таймер, отсчитывающий предельно допустимое время от
    // посылки нами информационного кадра к сети КСОН, до получения нами
    // пакета подтверждения от сети КСОН.
    QTimer* m_confirmTimer;

    // Время посылки информационного кадра от АПАК к КСОН. Оно необходимо нам, чтобы проверить,
    // что в пакете подтверждения от КСОН указано то же самое время.
    quint64 m_packetTimeTo_KSON;

    // Время из информационного кадра от КСОН. Оно необходимо нам, чтобы использовать его
    // в пакете подтверждения на этот информационный кадр:
    quint64 m_packetTimeFrom_KSON;

    // Счётчик подряд идущих ошибок взаимодействия АПАК с КСОН:
    uint m_interactionErrorCounter;

    // В этой переменной, при разборе информационного кадра от КСОН,
    // формируем поле статуса пакета подтверждения:
    quint64 m_status;

    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ ФОРМИРОВАНИЯ ИНФОРМАЦИОННОГО КАДРА ОТ АПАК К КСОН ====:
    // 1И. Битовый массив размером m_params.data_len*8 битов, в котором формируется "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к КСОН:
    QBitArray m_bitsInformBlock_to_KSON;

    // 2И. Байтовый массив размером m_params.data_len байтов, в котором хранится "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к КСОН:
    QByteArray m_byteInformBlock_to_KSON;

    // 3И. Битовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это индекс в этом массиве),
    //    устанавливает актуальны ли её сигналы (false - не актуальны, true - актуальны).
    //    Считаем, что все сигналы от АПАК (группы 0 - 9) - ВСЕГДА актуальны.
    QBitArray m_relevance_by_group_to_KSON;

    // 4И. Байтовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это номер бита в этом массиве),
    //    устанавливает актуальны ли её сигналы: значение бита 0 - не актуальны, 1 - актуальны).
    //    Считаем, что все сигналы от АПАК (группы 0 - 9) - ВСЕГДА актуальны.
    QByteArray m_relevanceGroup_Byte_to_KSON;

    // 5И. Информационный кадр от АПАК к КСОН:
    QByteArray m_send_data;

    // 6И. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock" ставит в соответствие сигнал, бит которого должен быть записан
    //    в массив "m_bitsInformBlock":
    QMap<uint16_t, modus::SvSignal*> m_signal_by_bitNumberInInformBlock_to_KSON;

    // 7И. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock", ставит в соответствие номер бита сигнала, который
    //    должен быть записан в массив "m_bitsInformBlock":
    QMap<uint16_t, uint8_t> m_bitNumberInSignal_by_bitNumberInInformBlock_to_KSON;


    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ РАЗБОРА И ПРОВЕРКИ ИНФОРМАЦИОННОГО КАДРА ОТ КСОН К АПАК ====:
    // 1В. Словарь, который каждому смещению (в байтах) значения сигнала относительно начала информационного
    //     блока, передаваемого из КСОН в АПАК, ставит в соответствие указатель на этот сигнал.
    QMap<uint8_t, modus::SvSignal*> m_signals_by_byte_from_KSON;

    // 2В. Список указателей на сигналы, отсортированный по возрастанию смещений
    //     значений сигналов (в байтах) относительно начала информационного блока,
    //     передаваемого из КСОН в АПАК.
    QList <modus::SvSignal*> m_signals_from_KSON;

    // 3В. Словарь, который каждому сигналу ставит в соответствие структуру SignalParams,
    //     хранящую параметры для этого сигнала:
    QMap<modus::SvSignal*, apak::SignalParams> m_params_by_signal_from_KSON;

    // 4В. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    //     определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    //     В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из наличия сигналов с
    //     параметром, указывающим на принадлежность к данной группе, в файле сигналов устройства КСОН.
    QBitArray m_relevance_by_group_from_KSON;

    // 5В. Указатель на сигнал - "данные от сети КСОН". Значение этого сигнала - это весь информационный
    //     кадр от КСОН, а не только блок параметрической информации из этого кадра.
    modus::SvSignal*      m_data_signal;

    // 6В. Указатель на сигнал - "состояние сети КСОН":
    modus::SvSignal*      m_state_signal;

    // 7В. Указатель на сигнал "время от сети КСОН":
    modus::SvSignal*      m_time_signal;


  public slots:
    void signalUpdated(modus::SvSignal* signal) override;
    void signalChanged(modus::SvSignal* signal) override;

    // В этой функции мы осуществляем:
    // 1. Cформируем список "m_signals_from_KSON", хранящий указатели на сигналы приходящие от КСОН.
    // Этот список отсортирован по возрастанию смещений значений сигналов (в байтах) относительно
    // начала информационного блока, передаваемого из КСОН в АПАК.
    // 2. Привязываем вызов функции "noReceivePackage" к наступлению таймаута
    // таймера приёма "m_receiveTimer". В этой функции мы будем фиксировать отсутствие
    // информационного кадра от КСОН.
    // 3. Запускаем таймер приёма "m_receiveTimer".
    // 4. Привязываем вызов функции "noConfirmationPackage" к наступлению таймаута
    // таймера подтверждения "m_confirmTimer". В этой функции мы будем фиксировать
     // ошибку взаимодействия КСОН и АПАК.
    // 5. Привязку вызова функции "sendInformFrame" , в которой мы
    // формируем информационный кадр от системы АПАК к сети КСОН, к наступлению таймаута
    // таймера посылки "m_sendTimer".
    // 6. Запускаем на единственное срабатывание таймер посылки "m_sendTimer" с периодом,
    // равным интервалу посылки информационных кадров,
    // от АПАК к КСОН, заданному  в конфигурационном файле "config_apak.json", как параметр
    // протокола устройства КСОН. Далее будем запускать
    // этот таймер каждый раз после получения пакета подтверждения от сети КСОН.
    // 7. Привязку вызова функции "packageFrom_KSON", к сигналу "modus::IOBuffer::dataReaded". Этот сигнал
    // испускается интерфейсной частью по приходу данных от интерефейса (в нашем случае - от сети КСОН).
    // 8. Сброс счётчика идущих подряд ошибок взаимодействия КСОН и АПАК
    void start(void) override;

  private slots:
    // В этой функции мы:
    // 1. Формируем и помещаем в массив байт "m_send_data" информационный кадр для передачи от
    // системы АПАК к сети КСОН  (в соответствии с протоколом обмена).
    // 2. Инициируем передачу этого кадра от протокольной к интерфейcной части
    // (для передачи по линии связи).
    // 3. Запускаем таймер подтверждения "m_confirmTimer", который отсчитывает
    // предельно допустимое время от посылки нами информационного кадра к сети КСОН,
    // до получения нами пакета подтверждения от сети КСОН.
    void sendInformFrame();

    // В этой функции мы обрабатываем принятое от КСОН сообщение.
    // Это сообщение, может состоять:
    // - из информационного кадра
    // - из пакета подтверждения
    // - из информационного кадра и пакета подтверждения в любом порядке.

    // Мы последовательно обрабатываем пакеты, из которых состоит принятое сообщение.
    // Тип пакета (информационный кадр или пакет подтверждения) мы определем по полю
    // размера данных.
    void messageFrom_KSON(modus::BUFF* buffer);

    // Функция осуществляет выделение из принятого от КСОН сообщения одного пакета и,
    // в зависимости от вида пакета (информационный кадр или пакет подтверждения), вызов для
    // его разбора сооответствующей функции:
    void analysisMessageFrom_KSON(QByteArray& messageFrom_KSON);

    // Функция обработки пришедшего от КСОН информационного кадра:
    // Аргумент функции: "packageFrom_KSON" - содержит информационный кадр от КСОН.
    void informFrameFrom_KSON (QByteArray packageFrom_KSON);

     // Функция обработки пришедшего от КСОН пакета подтверждения:
     // Аргумент функции: "packageFrom_KSON" - содержит пакет подтверждения от КСОН.
    void  confirmationPackageFrom_KSON (QByteArray packageFrom_KSON);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // посылки нами информационного кадра к КСОН, до получения нами пакета подтверждения от КСОН
    // пакет подтверждения так и не пришёл.
    void noConfirmationPackage(void);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // сети КСОН не пришёл инфомационный кадр.
    void noReceivePackage (void);

    // Формирование и посылка пакета подтверждения.
    void sendConfirmationPackage (void);

    // Обработка ошибки протокола.
    void protocolErrorHandling (QString str);

    // Функция передаёт данные от протокольной к интерфейcной части (для передачи по линии связи).
    // Аргумент: "data" - массив байт для передачи
    void transferToInterface (QByteArray data);
  };
}

#endif // KSON_PACK_H
