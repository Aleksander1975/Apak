#ifndef KSON_PACK_H
#define KSON_PACK_H


#include "kson_packet_global.h"

#include "protocol_params.h"
#include "signal_params.h"

#include "../../../global_apak_defs.h"

#include "../../../../Modus/global/device/protocol/sv_abstract_protocol.h"
#include "../../../../Modus/global/signal/sv_signal.h"
#include "../../../../svlib/SvAbstractLogger/1.2/sv_abstract_logger.h"
#include "../../../../svlib/SvException/1.1/sv_exception.h"
#include "../../../../svlib/SvCRC/1.0/sv_crc.h"

extern "C" {

     KSON_PACKET_EXPORT modus::SvAbstractProtocol* create();

//    VIRTUAL_DEVICESHARED_EXPORT QString defaultDeviceParams();
//    VIRTUAL_DEVICESHARED_EXPORT QString defaultIfcParams(const QString& ifc);
//    VIRTUAL_DEVICESHARED_EXPORT QList<QString> availableInterfaces();

}

namespace apak {


  class SvKsonPacket: public modus::SvAbstractProtocol
 // Класс, реализующий библиотеку АПАК для работы с КСОН.
  {
    Q_OBJECT

  public:
    // Инициализация структур данных, необходимых для формирования информационного кадра
    // от АПАК к КСОЕ, и структур данных, необходимых для разбора информационного
    // кадра от КСОН:
    SvKsonPacket();
    ~SvKsonPacket();

    // Эта функция вызывается серевером "mdserver" для всех устройств.
    // Её цель - инициализировать все структуры, необходимые нам для работы
    // с конкретным устройстовм (в данном случае, с КСОН).
    bool configure(modus::DeviceConfig* config, modus::IOBuffer *iobuffer) override;

    // Эта функция вызывается сервером "mdserver" для всех сигналов, связанных с сетью КСОН.
    // Цель этой функции состоит в получении всех параметров для каждого сигнала и заполнении в соответствии
    // с ними структур данных (перечисленных в файле "kson_packet.h"), необходимых для формирования
    // информационного кадра от системы АПАК к сети КСОН и проверки допустимости значений сигналов
    // информационного кадра от сети КСОН в систему АПАК.
    bool bindSignal(modus::SvSignal* signal, modus::SignalBinding binding) override;

  private:

    // Cодержит параметры протокола обмена сети КСОН с системой АПАК
    // (эти параметры описаны в файле "protokol_param.h").
    apak::ProtocolParams  m_params;


    // "Таймер посылки" - таймер, отсчитывающий период посылки информационных
    // кадров от сисмемы АПАК к сети КСОН:
    QTimer* m_sendTimer;

    // "Таймер приёма" - таймер, отсчитывающий предельно допустимое время между информационными
    // кадрами от сети КСОН к системе АПАК:
    QTimer* m_receiveTimer;

    // "Таймер подтверждения" - таймер, отсчитывающий предельно допустимое время от
    // посылки нами информационного кадра к сети КСОН, до получения нами
    // пакета подтверждения от сети КСОН.
    QTimer* m_conformTimer;

    // Время посылки информационного кадра от АПАК к КСОН. Оно необходимо нам, чтобы проверить,
    // что в пакете подтверждения от КСОН указано то же самое время.
    quint64 m_packetTimeTo_KSON;

    // Время из информационного кадра от КСОН. Оно необходимо нам, чтобы использовать его
    // в пакете подтверждения на этот информационный кадр:
    quint64 m_packetTimeFrom_KSON;

    // Счётчик подряд идущих ошибок взаимодействия АПАК с КСОН:
    uint m_interactionErrorCounter;

    // В этой переменной, при разборе информационного кадра от КСОН,
    // формируем поле статуса пакета подтверждения:
    uint8_t m_status;

    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ ФОРМИРОВАНИЯ ИНФОРМАЦИОННОГО КАДРА ОТ АПАК К КСОН ====:
    // 1И. Битовый массив размером m_params.data_len*8 битов, в котором формируется "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к КСОН:
    QBitArray m_bitsInformBlock_to_KSON;

    // 2И. Байтовый массив размером m_params.data_len байтов, в котором хранится "информационный блок"
    //    (длиной m_params.data_len байтов) информационного кадра от АПАК к КСОН:
    QByteArray m_byteInformBlock_to_KSON;

    // 3И. Битовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это индекс в этом массиве),
    //    устанавливает актуальны ли её сигналы (false - не актуальны, true - актуальны).
    //    Считаем, что все сигналы от АПАК (группы 0 - 9) - ВСЕГДА актуальны.
    QBitArray m_relevance_by_group_to_KSON;

    // 4И. Байтовый массив, который для каждого номера группы сигналов от АПАК к КСОН
    //    (номер - это номер бита в этом массиве),
    //    устанавливает актуальны ли её сигналы: значение бита 0 - не актуальны, 1 - актуальны).
    //    Считаем, что все сигналы от АПАК (группы 0 - 9) - ВСЕГДА актуальны.
    QByteArray m_relevanceGroup_Byte_to_KSON;

    // 5И. Информационный кадр от АПАК к КСОН:
    QByteArray m_send_data;

    // 6И. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock" ставит в соответствие сигнал, бит которого должен быть записан
    //    в массив "m_bitsInformBlock":
    QMap<uint16_t, modus::SvSignal*> m_signal_by_bitNumberInInformBlock_to_KSON;

    // 7И. Словарь, который каждому номеру бита (от 0 до m_params.data_len*8-1) из битового массива
    //    "m_bitsInformBlock", ставит в соответствие номер бита сигнала, который
    //    должен быть записан в массив "m_bitsInformBlock":
    QMap<uint16_t, uint8_t> m_bitNumberInSignal_by_bitNumberInInformBlock_to_KSON;


    // ==== СТРУКТУРЫ ДАННЫХ ДЛЯ РАЗБОРА И ПРОВЕРКИ ИНФОРМАЦИОННОГО КАДРА ОТ КСОН К АПАК ====:
    // 1В. Словарь, который каждому смещению (в байтах) значения сигнала относительно начала информационного
    //     блока, передаваемого из КСОН в АПАК, ставит в соответствие указатель на этот сигнал.
    QMap<uint8_t, modus::SvSignal*> m_signals_by_byte_from_KSON;

    // 2В. Список указателей на сигналы, отсортированный по возрастанию смещений
    //     значений сигналов (в байтах) относительно начала информационного блока,
    //     передаваемого из КСОН в АПАК.
    QList <modus::SvSignal*> m_signals_from_KSON;

    // 3В. Словарь, который каждому сигналу ставит в соответствие структуру SignalParams,
    //     хранящую параметры для этого сигнала:
    QMap<modus::SvSignal*, apak::SignalParams> m_params_by_signal_from_KSON;

    // 4В. Битовый массив, который для каждого номера группы сигналов (номер - это индекс в этом массиве),
    //     определяет актуальны ли её сигналы (false - не актуальны, true - актуальны).
    //     В этом массиве АКТУАЛЬНОСТЬ сигналов группы определяется, исходя из наличия сигналов с
    //     параметром, указывающим на принадлежность к данной группе, в файле сигналов устройства КСОН.
    QBitArray m_relevance_by_group_from_KSON;

    // 5В. Указатель на сигнал - "данные от сети КСОН". Значение этого сигнала - это весь информационный
    //     кадр от КСОН, а не только блок параметрической информации из этого кадра.
    modus::SvSignal*      m_data_signal;

    // 6В. Указатель на сигнал - "состояние сети КСОН":
    modus::SvSignal*      m_state_signal;

    // 7В. Указатель на сигнал "время от сети КСОН":
    modus::SvSignal*      m_time_signal;


  public slots:
    void signalUpdated(modus::SvSignal* signal) override;
    void signalChanged(modus::SvSignal* signal) override;

    // В этой функции мы осуществляем:
    // 1. Cформируем список "m_signals_from_KSON", хранящий указатели на сигналы приходящие от КСОН.
    // Этот список отсортирован по возрастанию смещений значений сигналов (в байтах) относительно
    // начала информационного блока, передаваемого из КСОН в АПАК.
    // 2. Привязываем вызов функции "noReceivePackage" к наступлению таймаута
    // таймера приёма "m_receiveTimer". В этой функции мы будем фиксировать отсутствие
    // информационного кадра от КСОН.
    // 3. Запускаем таймер приёма "m_receiveTimer".
    // 4. Привязываем вызов функции "noConfirmationPackage" к наступлению таймаута
    // таймера подтверждения "m_conformTimer". В этой функции мы будем фиксировать
     // ошибку взаимодействия КСОН и АПАК.
    // 5. Привязку вызова функции "sendInformFrame" , в которой мы
    // формируем информационный кадр от системы АПАК к сети КСОН, к наступлению таймаута
    // таймера посылки "m_sendTimer".
    // 6. Запускаем на единственное срабатывание таймер посылки "m_sendTimer" с периодом,
    // равным интервалу посылки информационных кадров,
    // от АПАК к КСОН, заданному  в конфигурационном файле "config_apak.json", как параметр
    // протокола устройства КСОН. Далее будем запускать
    // этот таймер каждый раз после получения пакета подтверждения от сети КСОН.
    // 7. Привязку вызова функции "packageFrom_KSON", к сигналу "modus::IOBuffer::dataReaded". Этот сигнал
    // испускается интерфейсной частью по приходу данных от интерефейса (в нашем случае - от сети КСОН).
    // 8. Сброс счётчика идущих подряд ошибок взаимодействия КСОН и АПАК
    void start(void) override;

  private slots:
    // В этой функции мы:
    // 1. Формируем и помещаем в массив байт "m_send_data" информационный кадр для передачи от
    // системы АПАК к сети КСОН  (в соответствии с протоколом обмена).
    // 2. Инициируем передачу этого кадра от протокольной к интерфейcной части
    // (для передачи по линии связи).
    // 3. Запускаем таймер подтверждения "m_conformTimer", который отсчитывает
    // предельно допустимое время от посылки нами информационного кадра к сети КСОН,
    // до получения нами пакета подтверждения от сети КСОН.
    void sendInformFrame();

    // В этой функции мы обрабатываем принятое от КСОН сообщение.
    // Это сообщение, может состоять:
    // - из информационного кадра
    // - из пакета подтверждения
    // - из информационного кадра и пакета подтверждения в любом порядке.

    // Мы последовательно обрабатываем пакеты, из которых состоит принятое сообщение.
    // Тип пакета (информационный кадр или пакет подтверждения) мы определем по полю
    // размера данных.
    void messageFrom_KSON(modus::BUFF* buffer);

    // Функция осуществляет выделение из принятого от КСОН сообщения одного пакета и,
    // в зависимости от вида пакета (информационный кадр или пакет подтверждения), вызов для
    // его разбора сооответствующей функции:
    void analysisMessageFrom_KSON(QByteArray& messageFrom_KSON);

    // Функция обработки пришедшего от КСОН информационного кадра:
    // Аргумент функции: "packageFrom_KSON" - содержит информационный кадр от КСОН.
    void informFrameFrom_KSON (QByteArray packageFrom_KSON);

     // Функция обработки пришедшего от КСОН пакета подтверждения:
     // Аргумент функции: "packageFrom_KSON" - содержит пакет подтверждения от КСОН.
    void  confirmationPackageFrom_KSON (QByteArray packageFrom_KSON);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // посылки нами информационного кадра к КСОН, до получения нами пакета подтверждения от КСОН
    // пакет подтверждения так и не пришёл.
    void noConfirmationPackage(void);

    // Эта функция вызывается в том случае, если в течении предельно допустимого времени от
    // сети КСОН не пришёл инфомационный кадр.
    void noReceivePackage (void);

    // Формирование и посылка пакета подтверждения.
    void sendConfirmationPackage (void);

    // Обработка ошибки протокола.
    void protocolErrorHandling (QString str);
  };
}

#endif // KSON_PACK_H
